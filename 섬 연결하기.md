# 섬 연결하기

URL: https://programmers.co.kr/learn/courses/30/lessons/42861#

# 문제

n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요.

다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다.

# 입출력

- 섬의 개수 n은 1 이상 100 이하입니다.
- costs의 길이는 ((n-1) * n) / 2이하입니다.
- 임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다.
- 같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다.
- 모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다.
- 연결할 수 없는 섬은 주어지지 않습니다.

|n|costs|return|
|---|------|---|
|4|[[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]]|4|

# 문제 접근 방법

1. 처음 보는 노드에서 가장 비용이 적은 연결을 더한다
2. 이제 그 노드가 연결되었으니 두 노드를 보며 가장 비용이 적은 연결을 더한다
3. 노드가 더해졌으니 더해진 노드까지 보며 가장 비용이 적은 연결을 더하는 작업을 반복한다

# 코드 
```python
def solution(n, costs):
    answer = 0
    # 경로를 저장할 list 제작
    lst = []
    for i in range(n):
        lst.append([9999999 for j in range(n)])
    for r in costs:
        lst[r[0]][r[1]] = r[2]
        lst[r[1]][r[0]] = r[2]
    visit = [False for i in range(n)]
    # 다음 순서로 찾는다
    # 1. 0 행을 보면서 가장 낮은 수를 찾는다
    # 2. 낮은 수와 낮은수가 있었던 열의 행에있는 수를 9999999로 만들고 방문한 행들을 보면서 방문 안한 가장 낮은 수를 찾는다
    # 3. 모든 행이 포함될때까지 2 번을 반복한다
    my_see = [0] # 내가 지금 보는 행
    for _ in range(n-1): # 어쨌든 n-1개 연결된다
        hang = 0
        yeol = 0 # 내가 보는 행들의 요소중 가장 작은숫자의 좌표
        ssada = 9999999
        for see in my_see:
            for i in range(n): # 이 행에서
                if ssada > lst[see][i] and (not i in my_see):
                    ssada = lst[see][i]
                    hang = see
                    yeol = i
        # 내가 볼 수 있는 행을 보두 보고 최소값과 그 좌표를 얻었다
        my_see.append(yeol) # 이제 연결되었다
        lst[hang][yeol] = 9999999
        lst[yeol][hang] = 9999999
        answer += ssada
        
        
    return answer
```

# 개선 사항
뇌가 굳은듯
